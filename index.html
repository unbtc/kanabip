
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ふっかつのじゅもん</title>
    <style>
        ul {
            margin: 30px;
            column-width: 110px;
            column-count: auto;
            padding: 20px;
            border: solid;
        }

        li {
            list-style-type: none;
            margin: 0 auto;
            padding: 0;
            min-width: 120px;
        }

        a {
            color: #FFBB00;
            padding: 0;
            background-image: linear-gradient(to right, rgba(0, 0, 0, 0) 50%, rgb(255, 187, 0) 50%);
            background-position: 0 0;
            background-size: 200% auto;
            transition: .3s;
            text-decoration: none;
        }

        a:hover {
            background-position: -100% 0;
            color: #FFBB00;
        }

        em {
            font-size: 0.5em;
        }

        strong {
            color: white;
        }

        h2 {
            color: #FFBB00;
        }

        h3 {
            color: #FFBB00;
        }

        #logo1 {
            font-size: 3em;
            font-family: HelveticaNeue-BoldItalic;
        }

        #logo2 {
            font-size: 3em;
            font-family: HelveticaNeue-LightItalic;
        }

        #mappings {
            color: #CA7FFF;
            font-size: 0.8em;
        }

        #date {
            color: #CA7FFF;
            font-size: 0.5em;
        }

        #header {
            width: 100%;
            vertical-align: middle;
            background: #eee;
            color: #CA7FFF;
            font-size: 0.8em;
            padding: 1em 0;
        }

        #pref {
            width: 420px;
            margin: 0 auto;
        }

        #date {
            text-align: center;
        }

        #btns {
            text-align: center;
        }

        #main {
            margin: 0 auto;
            padding: 0;
            min-width: 270px;
        }

        #chars {
            width: 98%;
            margin: 0 auto;
            border: solid 2px #FFBB00;
            color: #FFBB00;
            resize: vertical;
        }

        #hide {
            background: #444;
            color: #ddd;
        }

        .description {
            width: 420px;
            margin: 0 auto;
            padding: 0.5em;
        }

        .txt3 {
            display: inline-block;
            width: 6em;
            min-width: 6em;
            max-width: 100%;
            padding: 0;
            border: dashed #CA7FFF;
            border-width: 0px 0px 1px 0px;
            background: #fff;
            margin: 0 0 0 1em;
            color: #668;
        }

        .butn {
            background: #FFBB00;
            border: 0px;
            border-radius: 0.5em;
            appearance: none;
            color: #fff;
            margin: 2px 1px 8px 0px;
            font-size: 1em;
        }

        .butn:hover {
            background: #FFE700;
        }

        .butn:focus {
            outline: none;
            box-shadow: 0 0 0 1px #FFE700;
        }

        .img {
            width: 90%;
            padding: 1em;
        }

        @media print {
            li {
                color: black;
            }

            ul {
                border: dashed 1px #999;
            }

            .txt3 {
                border: dashed #999;
                border-width: 0px 0px 1px 0px;
            }
        }
    </style>
    <script>
        window.onload = () => {
            document.getElementById("date").innerText = new Date();
            updateCount();
            fetchBip39Words().then(() => {
                generate();
                putSuggest();
            });
        }

        const fetchBip39Words = async () => {
            const url = "https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/english.txt";
            let response = await fetch(url);
            let text = await response.text();
            bip39_words = text.split('\n').slice(0, 2 ** 11);
            console.log("bip39_words:", bip39_words);
        }

        // サジェスト生成
        const putSuggest = () => {
            let sugg_datalist = document.getElementById('bip39_suggest');
            sugg_datalist.innerHTML = ''; // Clear existing options
            for (let g = 0; g < bip39_words.length; g++) {
                let option = document.createElement('option');
                option.setAttribute("value", bip39_words[g]);
                sugg_datalist.appendChild(option);
            }
        }

        const getCombinations = (chars) => {
            const res = [];
            for (let c1 of chars) {
                for (let c2 of chars) {
                    res.push(`${c1}${c2}`);
                }
            }
            return res;
        }

        const shuffleArray = (arr) => {
    if (!Array.isArray(arr)) {
        console.error("shuffleArray: arr is not an array", arr);
        return [];
    }
    const copied = arr.concat();
    for (let i = copied.length - 1; i > 0; i--) {
        const j = crypto.getRandomValues(new Uint32Array(1))[0] % (i + 1);
        [copied[i], copied[j]] = [copied[j], copied[i]];
    }
    return copied;
}

        let mappings = {};
        const generate = () => {
            mappings = {};
            const custom_chars = document.getElementById("chars").value.split(",");
            const custom_words = getCombinations(custom_chars);

            // カスタムワードの数だけシャッフルされたBIP39単語リストを生成
            let extended_bip39_words = shuffleArray(bip39_words);

            // デバッグ用: extended_bip39_wordsの内容を確認
            console.log("extended_bip39_words after initial shuffle:", extended_bip39_words);

            // 足りない分を再度シャッフルして追加
            const requiredWords = custom_words.length;
            const bip39Length = bip39_words.length;
            while (extended_bip39_words.length < requiredWords) {
                const remaining = requiredWords - extended_bip39_words.length;
                extended_bip39_words = extended_bip39_words.concat(shuffleArray(bip39_words).slice(0, remaining));
            }

            // デバッグ用: extended_bip39_wordsの長さと内容を確認
            console.log("extended_bip39_words length:", extended_bip39_words.length);
            console.log("extended_bip39_words:", extended_bip39_words);

            // 全体をシャッフルして重複が均等に散らばるようにする
            extended_bip39_words = shuffleArray(extended_bip39_words);

            for (let i = 0; i < custom_words.length; i++) {
                mappings[custom_words[i]] = extended_bip39_words[i];
            }
            updateDisplay(Object.entries(mappings));
        }

        let mappings_fix = {};
        const generateFix = () => {
            mappings_fix = {};
            const custom_chars = document.getElementById("chars").value.split(",");
            const custom_words = getCombinations(custom_chars);
            let k = 0;

            for (let custom_word of custom_words) {
                mappings_fix[custom_word] = bip39_words[k % bip39_words.length];
                k++;
            }
            updateDisplayFix(Object.entries(mappings_fix));
        }

        const updateDisplay = (mappingList) => {
            const ul = document.getElementById("mappings");
            ul.innerHTML = '';

            for (let [custom_word, bip39_word] of mappingList) {
                const li = document.createElement("li");
                const input = document.createElement("input");
                input.setAttribute("autocomplete", "on");
                input.setAttribute("list", "bip39_suggest");
                input.setAttribute("name", "yourarea");
                input.setAttribute("type", "text");
                input.setAttribute("class", "txt3");
                input.setAttribute("value", `${bip39_word}`);
                input.addEventListener('change', (event) => handleInputChange(event, custom_word));

                const mapping = `${custom_word}`;
                const text = document.createTextNode(mapping);
                li.append(text);
                li.append(input);
                ul.appendChild(li);
            }
        }

        const handleInputChange = (event, custom_word) => {
            const newWord = event.target.value;
            const oldWord = mappings[custom_word];

            // Find the custom word that currently maps to the new word
            let existingCustomWord = null;
            for (let key in mappings) {
                if (mappings[key] === newWord) {
                    existingCustomWord = key;
                    break;
                }
            }

            // Swap the words
            if (existingCustomWord) {
                mappings[existingCustomWord] = oldWord;
            }
            mappings[custom_word] = newWord;

            // Update the display
            updateDisplay(Object.entries(mappings));
        }

        const updateDisplayFix = (mappingList) => {
            const ul = document.getElementById("mappings");
            ul.innerHTML = '';
            for (let i = 0; i < bip39_words.length; i++) {
                const [custom_word, bip39_word] = mappingList[i];
                const li = document.createElement("li");
                const input = document.createElement("input");
                input.setAttribute("class", "txt3");
                const mapping = `${custom_word}`;
                const text = document.createTextNode(mapping)
                input.setAttribute("value", `${bip39_word}`);
                li.append(text);
                li.append(input);
                ul.appendChild(li);
            }
        }

        const compareString = (a, b) => {
            if (a > b) {
                return 1;
            }
            if (a < b) {
                return -1;
            }
            return 0;
        }

        const sortByCustomWord = () => {
            if (mappings) {
                const mappingList = Object.entries(mappings);
                mappingList.sort((a, b) => compareString(a[0], b[0]));
                updateDisplay(mappingList);
            }
        }

        const sortByBip39Word = () => {
            if (mappings) {
                const mappingList = Object.entries(mappings);
                mappingList.sort((a, b) => compareString(a[1], b[1]));
                updateDisplay(mappingList);
            }
        }

        const print = (id) => {
            header = document.getElementById('header')
            header.style.display = "none"
            window.print();
            header.style.display = "block";
        }

        const updateCount = () => {
            const custom_chars = document.getElementById("chars").value.split(",");
            const count = custom_chars.length;
            document.getElementById("cnt").innerText = count;
        }
    </script>
</head>
<body>
    <div id="header">
        <div id="pref">
            <span id="logo1">Bip39</span>
            <span id="logo2">Hiragana</span>（※試験運用：自己責任）
            <br>
            <em>文字種（半角コンマ区切り）:
                <span id="cnt"></span>種類</em>
            <textarea onchange="updateCount()" id="chars">あ,い,う,え,お,か,き,く,け,こ,さ,し,す,せ,そ,た,ち,つ,て,と,な,に,ぬ,ね,の,は,ひ,ふ,へ,ほ,ま,み,む,め,も,や,ゆ,よ,ら,り,る,れ,ろ,わ,を,ん</textarea>
            <br>
            <div id="btns">
                <button class="butn" onclick="generate()">ランダム生成</button>
                <button class="butn" onclick="generateFix()">BIP39固定</button>
                <button class="butn" onclick="print()">表のみをプリント</button>
                <button class="butn" id="hidebtn" onclick="hideItem(); return false;" style="display: none;">使ってみる</button>
                <button class="butn" id="dispbtn" onclick="dispItem(); return false;">このツールの使い方</button>
            </div>
            <datalist id="bip39_suggest"></datalist>
        </div>

		<div id="hide" style="display: none;">
			<div class="description">

				<h2>BrainWalletの問題点</h2>
				<p>
					<strong>BrainWallet
						<em>（ブレインウォレット）</em>
					</strong>とは、ビットコイン等の暗号通貨の
					<strong>秘密鍵</strong>やニーモニック・ワードを
					<strong>脳内に記憶する為の方法</strong>の一つです。</p>
				<p>しかし、これには脆弱性があります。私たち人間はパスフレーズに何を使うか予測可能であり、辞書攻撃等によるハッキング技術は日々向上しています。パスワードの大規模なデータベースがいくつか流出しているので、これらをすべてハッシュ化し対応するアドレスに残高があるかどうかを確認することは非常に簡単です。同じ理由で、日本語のBIP39ワードリストから意味のある文章を作ったり<a href="https://github.com/armorybrainwallet/brain2bip" target="_blank">brain2bip</a>などの平文からBIP39ニーモニックを導き出すツールも推奨されません。</p>
				<h2>それで、このツールは何をしますか？</h2>
				<p>簡単に言えば、このツールの目的は
					<strong>「冗長化と記憶支援」</strong>です。鍵となる<strong>合言葉</strong>（24または48文字のひらがな平文）から独自の<strong>暗号表</strong>を作成し、辞書攻撃からあなたの大事なビットコインを守ります。また、ニーモニックをメモした
					<strong>物理的財布を紛失することを強く防ぎます</strong>。自分専用の暗号表と合言葉を作成したら、それを無くさないよう大事に保管してください。</p>
				<h2>使い方</h2>
				<p>1) 最初に
					<strong>紙と鉛筆</strong>を用意して下さい。<strong>決してPCやスマホは使わないで下さい</strong>。24文字の合言葉を作る場合（12フレーズ）例えば「私にはあなたを説得する時間はありません(I don't have time to try to convince you.)」という文章を合言葉にするなら、それをひらがなにして２文字ずつに分けます。</p>
				<p>わた　しに　はあ*　なた　をせ　つと</p>
				<p>くす　るじ　かん　はあ*　りま　せん</p>
				<p><strong>もし重複しているペアがあったら、合言葉を考え直します。</strong></p>
				<p>わた　しに　はあ　なた　をせ　つと</p>
				<p>くす　るじ　かん　
					<strong>があ</strong>　りま　せん</p>
				2) 合言葉の隣に、あなたが持っているBIP39ニーモニックを上から順に書き込んで下さい。
				<p>
					<img class="img" src="img/words.png">
				</p>
				<p>3) 次に、暗号表に打ち込む順番を決めます。キーロガー等のウィルスからニーモニック を守る為に、順番はランダムかつダミーとなるワードを間に挟んで入力する必要があります。以下のように隣に適当な順番で12までの数字を書きましょう。これで暗号表を作る準備が整いました。</p>
				<p>
					<img class="img" src="img/1.png">
				</p>
				<p>4) このツールをシークレットモードで開き、書いた数字の順番にワードを入力していきます。この例ではまず最初に「なた」の箇所に"grape"を打ちこめば良いことがわかります。以下のような感じで、</p>
				<p><img class="img" src="img/grape.png"></p>
				<p>単語の途中の文字を入れても自動的にサジェストされます。間にダミーを2〜5つほど変則的に加えながら、3)で書いた数字の順に入力して下さい。<strong>キーボードは極力使わずに</strong>、候補から選択します。ダミーを入力する箇所はなるべく広い範囲に、ワードは無作為に抽出します。</p>
					<p><img class="img" src="img/satoshi.png"></p>
					<p></p>
					<p>5) 12単語すべて入力し終わったら、上のボタンからPDFに出力して保存します<em>(リロードするとデータが消えてしまうので気をつけて下さい)</em>。印刷の向きや倍率を変えることで列の数を整えることができます。可読性に気をつけて大きさを調整して下さい。<em>※現在chromeのみ動作確認済※</em> PDFデータは単体ではなく、JPEG等の画像にも書き出して保存しておくことをお勧めします。</p><p><img class="img" src="img/print.png"></p>
				<p><strong>※セキュリティアップデート：重複単語が入れ替わるようになりました！</strong>例えばappleと入力された場所にbookと入力したい場合、どこかに必ずある「元からbookと入力されていた場所」の文字が自動的にapple、つまり上書きされた文字と入れ替わります。（以前はもともと重複がいくつか存在するように作られていましたが、この変更によりワードは2048種類必ず重複せず存在するため、セキュリティはより強固となり安心してお使いいただけるようになります。</p>	
				<p>6) 暗号表ができたら、それが読めるかどうかテストしてみましょう。まず<strong>合言葉を思い出します</strong>（これを忘れたら完全にアウト！あなたのビットコインは永久に失われてしまいました）。「私にはあなたを説得する時間がありません」でしたね。まず「わた」から初めて「せん」までの隣にある単語を探して下さい。</p><p><strong>ニーモニックは正しいですか？ウォレットが回復することをしっかり確認できたら、この作業に使ったメモは細切れにして厳重に処分して下さい。</strong></p>
				<h2>利点と注意点</h2>
				<p>この暗号表はコピーしていろいろな場所に保存することができます。しかし、オンラインに保管する場合は以下の点に注意してください。</p>
				<p>・
					<strong>E2E
						<em>(エンドツーエンド)</em>暗号化がされていないストレージ</strong>はなるべく使わない
					<br>・googleなどのストレージを使う場合は、何らかの方法で暗号化する</p>
				<p>以上の点に気を付ければ、USBメモリやCD-R、紙、ProtonmailなどのE2Eメールサービス等、実に様々な保存方法を活用して紛失を避けることができます。せっかく苦労して作ったのですから、
					<strong>５つ以上</strong>の保管方法で、同時に失う可能性がない環境を構築してみてください。冗長化は、このツールを使う上で
					<strong>最も大きなメリット</strong>です。ただし、この表がハッカーに盗まれてしまうと
					<strong>辞書攻撃が可能になってしまう</strong>点には十分注意して下さい。信頼できる人と共有するのであればまず大丈夫でしょう。</p><p>ただし、間違っても<strong>「合言葉」の方をインターネットやパソコンに保存することはしないで下さい</strong>。せっかく分断した２つの情報が結合してしまうことは、あなたの苦労を水の泡にし、あなたの財産が失われるきっかけになります。合言葉は必ず覚えるか、自分だけにしかわからない方法でメモしておいて下さい。短い合言葉ですから、それほど難しくはないはずです。</p>
					
					<h3>ちょっと待って！これはニーモニックのメモをクラウドに保存して、強力なパスフレーズで運用するのとどう違いますか？</h3><p>現状、代表的なHW<em>(ハードウェアウォレット)</em>ではパスフレーズを覚えてくれない場合が殆どで、毎回キーボードに打ち込むという手順が一般的に必要です。ニーモニックを危険に晒してパスフレーズに頼りきった場合、手間や障害点がメリットに対して大きすぎるという問題があります。暗号化の際にハードウェアを使うので、安全な環境が構築できない人には難しいため、HWの開発者がこれに対応してくれるまで、この暗号表を用いて冗長化することは比較的良い選択と言えます。</p>
					<h3>自分の好きな文字の種類（濁音やカタカナなど）で作ってもいいですか？</h3><p>ひらがなはカスタマイズできるようになっていますが、デフォルトの46文字より少なくすることは推奨していません。絶対に暗号表を誰かに見られない自信があるなら、思い切って30種類くらいで作ってみても良いかもしれません。ただし、<strong>ぢ</strong>や<strong>づ</strong>などの紛らわしい文字（音による判別が曖昧）は決して使わないようにして下さい。復号できなくなる可能性があります。デフォルトでは、<strong>濁音や小文字は濁点のない文字に読みかえる</strong>方法をとっています（暗号表が膨大になる為）。</p>
					<h3>合言葉はなんでもいいですか？（有名な詩など）</h3>
							<p><img class="img" src="img/yuutei.png"></p>
					<p>はじめに説明したように、辞書攻撃を避けるためにはなるべく一般的でない名詞や出来事を使う必要があります。暗号表をハッカーの目から隠すということを条件に覚えやすい言葉にすることは可能ですが、「覚えやすく、かつ完全なセキュリティを実現できる方法」は現在のところ存在しません。このツールはあくまで辞書攻撃を困難にすることと、物理的な紛失を防止することに重点を置いています。非常に安全である代わりに、全く意味不明な短い言葉で保存したい場合は<a href="https://github.com/unbtc/kana46/blob/main/hiragana.txt">こちら</a>の対応表を見てひらがな２文字によりニーモニックを短縮する方法をお勧めします。こちらは、暗号表が露出してもどうということはありませんし、失くしても簡単に再現できます。</p>
					<p><em>generation code: <a href="">makura@getalby.com</a> / ux & instructions:unbtc </a> / inspire: <a href="http://github.com/lokuyow">lokuyow@walletofsatoshi.com</a> / donation: <a href="mailto:LNURL1DP68GURN8GHJ7AMPD3KX2AR0VEEKZAR0WD5XJTNRDAKJ7TNHV4KXCTTTDEHHWM30D3H82UNVWQHHWUNED3SH2EMGXYCSPR5RZ6">LNURL</a>
</em></p>

				
			</div>
		</div>
	</div>
	<div>
		<p id="date"></p>
	</div>
	<div id="main">
		<ul id="mappings">
		</ul>
	</div>
	<script>
	//コンテンツの非表示
	    	function hideItem() {
	    	  document.getElementById('hide').style.display = "none";  //テキストエリアの非表示
	    	  document.getElementById('hidebtn').style.display = "none";  //非表示ボタンの非表示
	    	  document.getElementById('dispbtn').style.display = "";  //表示ボタンの表示
	    	}
	    
	    	//コンテンツの表示
	    	function dispItem() {
	    	  document.getElementById('hide').style.display = "";  //テキストエリアの表示
	    	  document.getElementById('hidebtn').style.display = "";  //非表示ボタンの表示
	    	  document.getElementById('dispbtn').style.display = "none";  //表示ボタンの非表示
	    	}
	</script>
</body>
</html>
